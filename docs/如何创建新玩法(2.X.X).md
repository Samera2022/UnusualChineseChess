# 如何创建新玩法 (2.X.X)

本文档旨在为开发者提供一个清晰的指南，说明如何在“不同寻常的中国象棋”项目中添加新的游戏玩法。项目采用基于规则的模块化设计，使得添加新功能变得简单直观。

## 核心理念

游戏的核心逻辑由一组可配置的**规则 (Rules)**驱动。每个新玩法都应被视为一条独立的规则。当规则被启用时，其对应的逻辑就会生效。这种设计的核心优势在于，玩法之间可以灵活组合，且代码高度解耦。

关键文件概览：
- `RuleRegistry.java`: **万物之始**。所有玩法的“户口本”，在这里注册新玩法。
- `MoveValidator.java`: **行棋逻辑**。如果你的玩法影响棋子如何移动，这是主要修改的文件。
- `BoardPanel.java`: **视觉表现**。如果你的玩法需要特殊的界面显示（如高亮、标记），在这里修改。
- `GameEngine.java`: **核心引擎**。处理游戏流程、状态变更等。复杂玩法可能需要修改此文件。
- `RuleSettingsPanel.java`: **UI界面**。根据 `RuleRegistry` 自动生成设置面板，**通常无需修改**。

---

## 开发流程

### 第一步：在 `RuleRegistry.java` 中注册新玩法

这是最重要的一步。你需要在这里定义新玩法的元数据。

打开 `src/io/github/samera2022/chinese_chess/rules/RuleRegistry.java`，在 `enum` 中添加一个新的条目。

**示例模板：**

```java
MY_NEW_RULE(
        "my_new_rule",              // 1. 注册名 (内部使用，全小写下划线)
        "我的新玩法",               // 2. 显示名称 (UI上显示)
        "这是一个新玩法的提示。",     // 3. 提示文本 (鼠标悬浮时显示，暂未使用)
        new String[]{},             // 4. 依赖的玩法 (依赖的玩法启用后，此项才能启用)
        new String[]{},             // 5. 冲突的玩法 (冲突的玩法启用后，此项将被禁用)
        true,                       // 6. 是否在UI上显示
        "extended",                 // 7. UI分组 ("outside", "extended", "special")
        Consts.CHECK_BOX,           // 8. UI控件类型 (CHECK_BOX 或 TEXT_AREA)
        false                       // 9. 默认值 (boolean for CHECK_BOX, int for TEXT_AREA)
),
```

**参数详解：**
1.  `registryName`: 规则的唯一标识符，用于在代码中获取规则状态。必须是唯一的。
2.  `displayName`: 在左侧设置面板中显示给用户的名称。
3.  `tooltip`: 鼠标悬停提示（当前版本暂未实现）。
4.  `dependentRegistryNames`: 依赖项。只有当数组中所有的规则都被启用时，此规则才能在UI上被勾选。例如，“允许境内后退”依赖于“兵卒可后退”。
5.  `conflictRegistryNames`: 冲突项。当数组中任何一个规则被启用时，此规则将被禁用。例如，“允许棋子堆叠”与“允许自己吃自己”是冲突的。
6.  `displayOnUI`: 是否在设置面板中显示。对于一些内部使用的或测试中的规则，可以设为 `false`。
7.  `targetComponent`: 决定此规则显示在哪个UI分组下。可选值为 `"outside"` (核心设置), `"extended"` (延申玩法), `"special"` (特殊玩法)。
8.  `type`: UI控件类型。`Consts.CHECK_BOX` 会生成一个复选框，`Consts.TEXT_AREA` 会生成一个带标签的文本输入框。
9.  `defaultValue`: 规则的默认值。对于复选框，应为 `true` 或 `false`；对于文本框，应为一个整数。

### 第二步：实现玩法逻辑

注册完规则后，你需要让它在游戏中生效。

#### 2.1. 如果玩法影响棋子的移动

这是最常见的情况。你需要修改 `MoveValidator.java`。

打开 `src/io/github/samera2022/chinese_chess/rules/MoveValidator.java`。

在 `isValidMove` 方法中，你可以通过 `rulesConfig` 对象来获取当前规则的设置值。

**示例：实现“兵可以后退”**
```java
// 在 isValidMove 方法的兵卒移动逻辑中
if (piece.getType() == Piece.Type.RED_SOLDIER || piece.getType() == Piece.Type.BLACK_SOLDIER) {
    // ... 其他兵卒逻辑

    // 检查“兵卒可后退”规则是否启用
    if (rulesConfig.getBoolean(RuleRegistry.PAWN_CAN_RETREAT.registryName)) {
        // 如果启用，则允许后退一步
        if (isRetreating(fromRow, toRow, piece.isRed())) {
            return true; // 这是一个有效的后退移动
        }
    }

    // ... 其他逻辑
}
```

#### 2.2. 如果玩法影响视觉表现

例如，你想高亮某些棋子或在棋盘上绘制特殊标记。你需要修改 `BoardPanel.java`。

打开 `src/io/github/samera2022/chinese_chess/ui/BoardPanel.java`。

在 `paintComponent` 方法或其调用的绘制辅助方法（如 `drawPieces`, `drawMoveIndicators`）中，添加你的绘制逻辑。

**示例：实现“显示提示”**
在 `drawMoveIndicators` 方法中，我们添加了一个判断：
```java
private void drawMoveIndicators(Graphics2D g2d, Board board) {
    // ... 绘制选中棋子的高亮

    // 检查“显示提示”规则
    if (rulesConfig.getBoolean(RuleRegistry.SHOW_HINTS.registryName)) {
        g2d.setColor(VALID_MOVE_COLOR);
        for (Point p : validMoves) {
            // 绘制绿色提示点
            int[] display = logicToDisplay(p.x, p.y);
            int moveX = display[1] * cellSize;
            int moveY = display[0] * cellSize;
            g2d.fillOval(moveX - 5, moveY - 5, 10, 10);
        }
    }

    // ... 绘制强制走子指示器
}
```

#### 2.3. 如果玩法涉及复杂的游戏流程

如果你的玩法超出了单步行棋验证的范畴（例如，改变胜负条件、触发特殊对话框等），你可能需要修改以下文件：

-   `GameEngine.java`: 用于修改核心游戏状态，如`checkGameState`（检查游戏结束状态）或`makeMove`（执行移动的核心逻辑）。
-   `ChineseChessFrame.java`: 用于处理与UI的复杂交互，例如在特定条件下弹出对话框（如“兵卒晋升”）。

### 第三步：测试你的新玩法

1.  **启动游戏**：运行 `ChineseChessFrame.java`。
2.  **检查UI**：在左侧的“玩法设置”面板中，确保你的新玩法已正确显示，并且其依赖和冲突关系符合预期。
3.  **功能测试**：
    -   启用你的新玩法，测试其功能是否如你所设计。
    -   禁用你的新玩法，确保游戏恢复到没有该玩法时的正常逻辑。
    -   测试它与其他相关玩法的组合，特别是你定义的依赖项和冲突项。

---

## 总结

添加一个新玩法通常遵循以下流程：

1.  在 `RuleRegistry.java` 中**定义规则**。
2.  根据玩法类型，在 `MoveValidator.java` (行棋逻辑) 或 `BoardPanel.java` (视觉逻辑) 中**实现功能**。
3.  **无需修改UI代码**，`RuleSettingsPanel` 会自动完成。
4.  **充分测试**。

祝你开发愉快！
