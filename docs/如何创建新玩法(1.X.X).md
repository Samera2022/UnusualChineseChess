# 如何正确创建一个新的玩法

本文档详细说明如何在《不寻常中国象棋》项目中添加新的游戏玩法规则。

## 目录
- [概述](#概述)
- [核心架构](#核心架构)
- [创建新玩法的步骤](#创建新玩法的步骤)
- [示例：添加"兵可以横向移动"规则](#示例添加兵可以横向移动规则)
- [常见问题](#常见问题)
- [最佳实践](#最佳实践)

---

## 概述

项目采用**集中式规则配置管理**架构，规则配置通过以下流程传递：

```
RuleConstants → GameRulesConfig → GameEngine ↔ MoveValidator
                                      ↕
                               RuleSettingsPanel (UI)
```

所有规则都通过 `GameRulesConfig` 作为**单一数据源**进行管理，避免在多处重复定义。

---

## 核心架构

### 1. **RuleConstants.java**
- **位置**：`src/io/github/samera2022/chinese_chess/rules/RuleConstants.java`
- **作用**：定义所有规则的字符串常量，避免硬编码
- **内容**：每个规则用一个 `public static final String` 常量表示

### 2. **GameRulesConfig.java**
- **位置**：`src/io/github/samera2022/chinese_chess/rules/GameRulesConfig.java`
- **作用**：存储和管理所有规则的实际值
- **功能**：
  - 定义规则字段（`private boolean/int`）
  - 提供 getter/setter 方法
  - 序列化/反序列化（JSON）
  - 通用动态访问方法（`get()`、`set()`、`getBoolean()`、`getInt()`）

### 3. **MoveValidator.java**
- **位置**：`src/io/github/samera2022/chinese_chess/rules/MoveValidator.java`
- **作用**：验证棋子移动的合法性，根据规则配置判断
- **实现**：在 `isValidMove()` 和各棋子的移动方法中通过 `r(RuleConstants.XXX)` 检查规则

### 4. **GameEngine.java**
- **位置**：`src/io/github/samera2022/chinese_chess/engine/GameEngine.java`
- **作用**：游戏逻辑核心，管理游戏状态、棋盘、规则配置
- **职责**：将 `rulesConfig` 注入到 `MoveValidator` 和 `CheckDetector`

### 5. **RuleSettingsPanel.java**
- **位置**：`src/io/github/samera2022/chinese_chess/ui/RuleSettingsPanel.java`
- **作用**：UI 面板，让用户配置游戏规则
- **功能**：提供复选框、文本框等控件，并通过 `SettingsBinder` 接口与 `GameEngine` 绑定

---

## 创建新玩法的步骤

### 第一步：在 RuleConstants 中定义常量

在 `RuleConstants.java` 中添加规则的字符串常量：

```java
public static final String YOUR_NEW_RULE = "yourNewRule";  // 简短描述
```

**命名规范**：
- 使用驼峰命名法（camelCase）
- 名称要清晰描述规则含义
- 添加中文注释说明

**示例**：
```java
public static final String PAWN_CAN_MOVE_SIDEWAYS = "pawnCanMoveSideways";  // 兵可以横向移动
```

---

### 第二步：在 GameRulesConfig 中添加字段和方法

在 `GameRulesConfig.java` 中完成以下操作：

#### 2.1 添加私有字段

```java
private boolean yourNewRule = false;  // 默认值为 false（或其他合适的默认值）
```

#### 2.2 在 `copy()` 方法中添加复制逻辑

```java
public GameRulesConfig copy() {
    GameRulesConfig config = new GameRulesConfig();
    // ...existing code...
    config.yourNewRule = this.yourNewRule;
    return config;
}
```

#### 2.3 在 `toJson()` 方法中添加序列化

```java
public JsonObject toJson() {
    JsonObject json = new JsonObject();
    // ...existing code...
    json.addProperty(RuleConstants.YOUR_NEW_RULE, yourNewRule);
    return json;
}
```

#### 2.4 在 `loadFromJson()` 方法中添加反序列化

```java
public void loadFromJson(JsonObject json) {
    // ...existing code...
    if (json.has(RuleConstants.YOUR_NEW_RULE)) {
        yourNewRule = json.get(RuleConstants.YOUR_NEW_RULE).getAsBoolean();
    }
}
```

#### 2.5 添加 Getter 和 Setter

```java
// Getters
public boolean isYourNewRule() { return yourNewRule; }

// Setters
public void setYourNewRule(boolean value) { this.yourNewRule = value; }
```

#### 2.6 在 `get()` 和 `set()` 方法的 switch 中添加分支

```java
public Object get(String ruleName) {
    switch (ruleName) {
        // ...existing code...
        case RuleConstants.YOUR_NEW_RULE: return yourNewRule;
        default: return null;
    }
}

public void set(String ruleName, Object value) {
    if (value instanceof Boolean) {
        boolean boolValue = (Boolean) value;
        switch (ruleName) {
            // ...existing code...
            case RuleConstants.YOUR_NEW_RULE: yourNewRule = boolValue; break;
        }
    }
    // ...
}
```

---

### 第三步：在 MoveValidator 中实现规则逻辑

在 `MoveValidator.java` 中应用新规则：

#### 3.1 添加 Getter/Setter（可选）

```java
public void setYourNewRule(boolean allow) { rulesConfig.setYourNewRule(allow); }
public boolean isYourNewRule() { return rulesConfig.isYourNewRule(); }
```

#### 3.2 在相关移动方法中检查规则

使用 `r(RuleConstants.YOUR_NEW_RULE)` 方法来检查规则是否启用：

```java
private boolean isValidSoldierMove(int fromRow, int fromCol, int toRow, int toCol, Piece piece) {
    // ...existing code...
    
    // 新规则：兵可以横向移动
    if (r(RuleConstants.PAWN_CAN_MOVE_SIDEWAYS)) {
        // 允许同行移动一格
        if (Math.abs(toCol - fromCol) == 1 && toRow == fromRow) {
            return true;
        }
    }
    
    // ...existing code...
}
```

**注意**：
- 使用 `r(RuleConstants.XXX)` 检查布尔规则
- 使用 `ri(RuleConstants.XXX)` 检查整数规则
- 规则检查应该放在合适的位置，不要破坏原有逻辑

---

### 第四步：在 RuleSettingsPanel 中添加 UI 控件

在 `RuleSettingsPanel.java` 中完成以下操作：

#### 4.1 在 `SettingsBinder` 接口中添加方法

```java
public interface SettingsBinder {
    // ...existing code...
    void setYourNewRule(boolean allow);
    boolean isYourNewRule();
}
```

#### 4.2 在构造函数中创建 UI 控件

```java
// 在适当的面板（special、special2 或 special3Content）中添加
JCheckBox chkYourNewRule = new JCheckBox("兵可以横向移动");
chkYourNewRule.setAlignmentX(Component.LEFT_ALIGNMENT);
chkYourNewRule.setToolTipText("允许兵在同一行左右移动一格");
specialContent.add(chkYourNewRule);
```

#### 4.3 绑定控件与 SettingsBinder

在 `bind()` 方法中添加：

```java
public void bind(SettingsBinder binder) {
    // ...existing code...
    
    // 在 applyState 中添加
    Runnable applyState = () -> {
        // ...existing code...
        chkYourNewRule.setSelected(binder.isYourNewRule());
    };
    
    // 在 applyChanges 中添加
    Runnable applyChanges = () -> {
        // ...existing code...
        binder.setYourNewRule(chkYourNewRule.isSelected());
    };
    
    // 添加监听器
    chkYourNewRule.addActionListener(e -> applyChanges.run());
    
    // ...existing code...
}
```

---

### 第五步：在 GameEngine 中实现 SettingsBinder 接口

在 `GameEngine.java` 中实现新方法：

```java
// 实现 SettingsBinder 接口的方法
public void setYourNewRule(boolean allow) { 
    rulesConfig.setYourNewRule(allow); 
}

public boolean isYourNewRule() { 
    return rulesConfig.isYourNewRule(); 
}
```

---

### 第六步：测试新规则

1. **编译运行项目**
2. **打开玩法设置面板**
3. **启用新规则并开始游戏**
4. **验证规则是否按预期工作**
5. **测试保存/加载配置是否正常**
6. **测试规则的边界情况和与其他规则的交互**

---

## 示例：添加"兵可以横向移动"规则

### 完整实现代码

#### 1. RuleConstants.java

```java
public static final String PAWN_CAN_MOVE_SIDEWAYS = "pawnCanMoveSideways";  // 兵可以横向移动
```

#### 2. GameRulesConfig.java

```java
// 字段
private boolean pawnCanMoveSideways = false;

// copy() 方法
config.pawnCanMoveSideways = this.pawnCanMoveSideways;

// toJson() 方法
json.addProperty(RuleConstants.PAWN_CAN_MOVE_SIDEWAYS, pawnCanMoveSideways);

// loadFromJson() 方法
if (json.has(RuleConstants.PAWN_CAN_MOVE_SIDEWAYS)) {
    pawnCanMoveSideways = json.get(RuleConstants.PAWN_CAN_MOVE_SIDEWAYS).getAsBoolean();
}

// Getter/Setter
public boolean isPawnCanMoveSideways() { return pawnCanMoveSideways; }
public void setPawnCanMoveSideways(boolean value) { this.pawnCanMoveSideways = value; }

// get() 方法
case RuleConstants.PAWN_CAN_MOVE_SIDEWAYS: return pawnCanMoveSideways;

// set() 方法
case RuleConstants.PAWN_CAN_MOVE_SIDEWAYS: pawnCanMoveSideways = boolValue; break;
```

#### 3. MoveValidator.java

```java
// Getter/Setter
public void setPawnCanMoveSideways(boolean allow) { rulesConfig.setPawnCanMoveSideways(allow); }
public boolean isPawnCanMoveSideways() { return rulesConfig.isPawnCanMoveSideways(); }

// isValidSoldierMove() 方法中添加
private boolean isValidSoldierMove(int fromRow, int fromCol, int toRow, int toCol, Piece piece) {
    int rowDiff = Math.abs(toRow - fromRow);
    int colDiff = Math.abs(toCol - fromCol);
    
    // 新规则：兵可以横向移动
    if (r(RuleConstants.PAWN_CAN_MOVE_SIDEWAYS)) {
        if (rowDiff == 0 && colDiff == 1) {
            return true;  // 允许横向移动一格
        }
    }
    
    // ...existing code...
}
```

#### 4. RuleSettingsPanel.java

```java
// SettingsBinder 接口
void setPawnCanMoveSideways(boolean allow);
boolean isPawnCanMoveSideways();

// 构造函数中创建控件
JCheckBox chkPawnCanMoveSideways = new JCheckBox("兵可以横向移动");
chkPawnCanMoveSideways.setAlignmentX(Component.LEFT_ALIGNMENT);
specialContent.add(chkPawnCanMoveSideways);

// bind() 方法中
chkPawnCanMoveSideways.setSelected(binder.isPawnCanMoveSideways());
chkPawnCanMoveSideways.addActionListener(e -> {
    binder.setPawnCanMoveSideways(chkPawnCanMoveSideways.isSelected());
});
```

#### 5. GameEngine.java

```java
public void setPawnCanMoveSideways(boolean allow) { 
    rulesConfig.setPawnCanMoveSideways(allow); 
}

public boolean isPawnCanMoveSideways() { 
    return rulesConfig.isPawnCanMoveSideways(); 
}
```

---

## 常见问题

### Q1: 为什么要在这么多地方添加代码？

**A**: 这是为了保持代码的**低耦合**和**高内聚**：
- `RuleConstants`：集中管理常量，避免魔法字符串
- `GameRulesConfig`：单一数据源，负责存储和序列化
- `MoveValidator`：业务逻辑层，负责规则判断
- `RuleSettingsPanel`：UI 层，负责用户交互
- `GameEngine`：控制层，协调各个组件

### Q2: 规则之间有冲突怎么办？

**A**: 在 `RuleSettingsPanel` 中添加互斥逻辑：

```java
chkRuleA.addActionListener(e -> {
    if (chkRuleA.isSelected()) {
        chkRuleB.setSelected(false);
        chkRuleB.setEnabled(false);
    } else {
        chkRuleB.setEnabled(true);
    }
});
```

参考现有的 `chkAllowPieceStacking` 和 `chkAllowCaptureOwnPiece` 的互斥实现。

### Q3: 如何添加整数类型的规则？

**A**: 参考 `MAX_STACKING_COUNT` 的实现：

1. 在 `GameRulesConfig` 中使用 `private int` 字段
2. 在 `toJson()` 使用 `addProperty()`
3. 在 `loadFromJson()` 使用 `getAsInt()`
4. 在 `set()` 方法中添加 `instanceof Integer` 分支
5. 在 UI 中使用 `JTextField` 并添加 `DocumentInputFilter` 限制输入

### Q4: 如何测试新规则是否正确实现？

**A**: 按以下顺序测试：

1. **编译通过**：确保没有语法错误
2. **UI 显示**：确认复选框正确显示
3. **状态绑定**：勾选/取消勾选，确认状态正确传递
4. **逻辑验证**：启用规则后，在棋盘上测试移动
5. **保存加载**：保存配置到文件，重新加载后验证
6. **规则组合**：测试与其他规则的交互是否正常

---

## 最佳实践

### 1. **命名规范**
- 常量名：大写下划线分隔（`PAWN_CAN_RETREAT`）
- 字段名：驼峰命名（`pawnCanRetreat`）
- 方法名：`is/get/set` + 驼峰命名

### 2. **注释规范**
- 在 `RuleConstants` 中添加中文注释
- 在 `GameRulesConfig` 字段后添加简短说明
- 在复杂的规则逻辑处添加详细注释

### 3. **默认值选择**
- 一般规则默认为 `false`（不启用）
- 整数类型选择合理的默认值
- 确保默认配置下是标准象棋规则

### 4. **UI 设计**
- 分组放置相关规则
- 添加工具提示（`setToolTipText()`）
- 使用缩进表示规则的层级关系
- 处理好规则之间的依赖和互斥

### 5. **规则实现**
- 优先检查新规则，避免影响原有逻辑
- 使用 `r()` 和 `ri()` 方法而不是直接访问 `rulesConfig`
- 考虑规则的边界情况和异常处理
- 确保规则不会导致死循环或性能问题

### 6. **测试覆盖**
- 测试规则启用和禁用的情况
- 测试规则与其他规则的组合
- 测试极端情况（如棋子在边界）
- 测试配置的保存和加载

### 7. **代码审查清单**

在提交代码前，确认已完成以下所有项：

- [ ] `RuleConstants` 中添加了常量
- [ ] `GameRulesConfig` 的 7 个位置都已修改（字段、copy、toJson、loadFromJson、getter、setter、get/set）
- [ ] `MoveValidator` 中实现了规则逻辑
- [ ] `RuleSettingsPanel` 中添加了 UI 控件和绑定逻辑
- [ ] `GameEngine` 中实现了 `SettingsBinder` 接口方法
- [ ] 添加了必要的注释和文档
- [ ] 已通过编译和基本测试
- [ ] 检查了代码格式和命名规范

---

## 附录：文件结构速查表

| 文件 | 位置 | 需要修改的内容 |
|------|------|---------------|
| `RuleConstants.java` | `src/.../rules/` | 添加常量定义 |
| `GameRulesConfig.java` | `src/.../rules/` | 添加字段、getter/setter、序列化方法 |
| `MoveValidator.java` | `src/.../rules/` | 实现规则逻辑 |
| `RuleSettingsPanel.java` | `src/.../ui/` | 添加 UI 控件和绑定 |
| `GameEngine.java` | `src/.../engine/` | 实现接口方法 |

---

## 结语

遵循本文档的步骤，你可以安全、规范地向项目中添加新的游戏玩法。如果遇到问题，可以参考现有规则的实现（如 `PAWN_CAN_RETREAT`、`ALLOW_FLYING_GENERAL` 等）作为模板。

**祝你开发顺利！** 🎉

